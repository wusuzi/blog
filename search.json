[{"title":"FormData对象与jquery踩坑记录","url":"/2023/07/01/FormData%E5%AF%B9%E8%B1%A1%E4%B8%8Ejquery%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","content":"\n\nFormData 对象与 jquery 踩坑记录场景介绍\n使用 tinymce 的 images_upload_handler 函数获取对象为 bold 类型 老项目中使用的是 jquery 做网络请求\n直接传递网络请求中不支持直接传递文件格式 比如此处的bold类型和file类型 由此需要使用formData\n\nformData 使用const formData = new FormData();let file = convertBlobToFile(blob, fileName);// 将 Blob 文件对象转换为 file 对象并添加到 FormData 对象中formData.append(&quot;file&quot;, file);\n\n此处加完后直接 console.log(formData)为空\nFormData &#123;&#125;\n\n但是！\nfor (let key of formData.entries()) &#123;  console.log(key); // [&#x27;file&#x27;, File]&#125;\n\n这样子打印就可以看见数据了(其中 File 为文件对象)\n上传时报错Illegal invocation\n\n此错误时由于网络请求中错误的参数导致的 因为之前上传图片接口为传递 base64 字符串所以没有出现此问题\n$.post(\tconfig.env + &#x27;rcBBS/saveWXSmallPicture&#x27;,    &#123;    \tfile：file,//此处file为base64字符串    &#125;,    function (data) &#123;        if (data.resultCode == 1) &#123;        \tlet imageUrl = data.resultMapList[0].image;        \tsuccess(imageUrl)        &#125;    &#125;);\n\n上传文件时错误的版本 报错 Illegal invocation 为 tinymce 提示\n是指函数被调用时，传递了一个不合法的参数，导致该函数无法正常执行。\n$.post(config.env + &quot;rcBBS/saveWXSmallPicture&quot;, formData, function (data) &#123;  if (data.resultCode == 1) &#123;    let imageUrl = data.resultMapList[0].image;    success(imageUrl);  &#125;&#125;);\n\n从你的代码片段来看，这里的 $.post() 函数是 jQuery 库中的函数，而不是原生的 fetch() 或 XMLHttpRequest 函数。\njQuery 的 $.post() 函数并不直接为上传文件设计，可能无法正确处理 FormData 对象。如果你需要进行文件上传，可以使用 jQuery.ajax() 函数并设置合适的 contentType 和 processData 选项，以将文件作为二进制数据上传。\n$.ajax(&#123;  url: config.env + &quot;rcBBS/saveWXSmallPicture&quot;,  method: &quot;POST&quot;,  data: formData,  contentType: false, // 将 contentType 设置为 false，并关闭 processData 选项  processData: false, // 否则可能会导致数据被序列化或者丢失  success(data) &#123;    if (data.resultCode == 1) &#123;      let imageUrl = data.resultMapList[0].image;      success(imageUrl);    &#125;  &#125;,  error(error) &#123;    console.error(error);  &#125;,&#125;);\n\n主要在于 contentType 和 processData 的设置 设置完毕后就可以正常使用了^_^\n","categories":["bug踩坑"],"tags":["javaScript"]},{"title":"GSAP属性","url":"/2023/03/04/GSAP%E5%B1%9E%E6%80%A7/","content":"\n\n\nGSAP 属性defaultsgsap.defaults(&#123; overwrite: &quot;auto&quot;, duration: 0.3 &#125;);\n\n这段代码使用 gsap.defaults()方法设置了 TweenMax 和 TweenLite 的默认选项。它将 overwrite 属性设置为’auto’，这意味着 TweenMax 和 TweenLite 将自动检测并解决可能的冲突。它还将 duration 属性设置为 0.3 秒，这意味着 TweenMax 和 TweenLite 将使用 0.3 秒的时间来完成所有动画。你可以根据需要调整这些选项，以实现你想要的效果。\neaseGSAP 库中有许多不同的缓动函数，可以用于控制动画的速度和加速度。这些缓动函数可以通过 ease 属性来指定。\n以下是一些常用的缓动函数：\n\nLinear.easeNone：匀速运动，没有加速度或减速度。\nPower1.easeIn：缓慢加速，然后突然停止。\nPower1.easeOut：突然开始，然后缓慢减速。\nPower1.easeInOut：缓慢加速，然后缓慢减速。\nPower2.easeIn：缓慢加速，然后更快地加速，最后突然停止。\nPower2.easeOut：突然开始，然后缓慢减速，最后更慢地减速。\nPower2.easeInOut：缓慢加速，然后更快地加速，然后缓慢减速。\nPower3.easeIn：缓慢加速，然后更快地加速，然后更快地加速，最后突然停止。\nPower3.easeOut：突然开始，然后缓慢减速，然后更慢地减速，最后更慢地减速。\nPower3.easeInOut：缓慢加速，然后更快地加速，然后更快地加速，然后缓慢减速。\nBack.easeIn：缓慢加速，然后超过目标值，最后回弹到目标值。\nBack.easeOut：突然开始，然后超过目标值，最后缓慢减速。\nBack.easeInOut：缓慢加速，然后超过目标值，然后缓慢减速。\nElastic.easeIn：缓慢加速，然后超过目标值，然后反弹几次，最后停止。\n\nDraggableDraggable.create()方法接受一个对象作为参数，该对象包含以下属性：\n\ntype：要创建的拖动类型。可以是”top”、”left”、”x”、”y”、”scroll”或”rotation”。\ntrigger：要触发拖动的元素或选择器。\nbounds：拖动的边界。可以是元素、选择器、数组或对象。\nedgeResistance：拖动到边缘时的阻力。可以是像素值或百分比。\nthrowProps：是否启用 ThrowPropsPlugin 插件。如果设置为 true，则可以使用 TweenMax 或 TweenLite 等 Tween 类来模拟物理抛掷效果。\nonPress：当按下鼠标或触摸屏时要执行的回调函数。\nonDrag：当拖动时要执行的回调函数。\nonRelease：当释放鼠标或触摸屏时要执行的回调函数。\nonThrowUpdate：当使用 ThrowPropsPlugin 插件模拟抛掷效果时要执行的回调函数。\nonThrowComplete：当使用 ThrowPropsPlugin 插件模拟抛掷效果完成时要执行的回调函数。\nsnap：是否启用吸附效果。如果设置为 true，则可以指定吸附点或吸附网格。\nsnapPoints：吸附点的数组。每个吸附点都是一个对象，包含 x 和 y 属性。\nsnapMode：吸附模式。可以是”grid”或”points”。\nsnapStart：吸附开始时的回调函数。\nsnapEnd：吸附结束时的回调函数。\nzIndexBoost：是否在拖动时提高元素的 z-index 值。如果设置为 true，则可以确保元素始终在其他元素的上方。\ncursor：拖动时要使用的光标类型。可以是”grab”、”grabbing”或自定义光标的 URL。\nlockAxis：是否锁定拖动的\n\nScrollTriggerScrollTrigger 是 GSAP 的一个插件，它可以帮助你在滚动时触发动画。以下是一些常用的 ScrollTrigger 属性：\ntrigger触发器元素或选择器，用于指定触发动画的元素。\nstart&#x2F;end触发动画的位置&#x2F;动画结束的位置，可以是像素值、百分比或关键字（例如”top”或”center”）。\n在使用 GSAP 的 ScrollTrigger 插件时，start属性用于指定滚动触发器的开始位置。start属性可以是字符串、数字或函数，并且支持各种单位（例如像素、百分比、视口高度等）。\n以下是start属性的详细解释：\n\n字符串: 可以使用字符串来指定开始位置。可以使用以下字符串值之一：\n“top”：元素顶部与视口顶部对齐。\n“center”：元素的中心与视口的中心对齐。\n“bottom”：元素底部与视口底部对齐。\n其他字符串：可以是任何有效的 CSS 单位，例如”100px”、”50%”等。\n\n\n数字: 可以使用数字来指定开始位置。数字表示滚动容器的滚动距离（以像素为单位），相对于元素的顶部。\n函数: 可以使用函数来动态计算开始位置。这个函数将接收一个参数，表示元素的 DOM 节点。函数应该返回一个数字，表示滚动容器的滚动距离（以像素为单位），相对于元素的顶部。\n\n例如，如果你想让元素在视口顶部的 50%处触发动画，可以将start属性设置为”50%”：\nScrollTrigger.create(&#123;  trigger: &quot;.box&quot;,  start: &quot;50%&quot;,&#125;);\n\n如果你想让元素在视口向上滚动 100 像素时触发动画，可以将start属性设置为 100：\nScrollTrigger.create(&#123;  trigger: &quot;.box&quot;,  start: 100,&#125;);\n\n如果你想动态计算开始位置，可以使用一个函数来返回计算结果：\nScrollTrigger.create(&#123;  trigger: &quot;.box&quot;,  start: function() &#123;    return window.innerHeight / 2;  &#125;,&#125;);\n\n需要注意的是，start属性可以根据需要进行配置，以控制滚动触发器的开始位置。\nscrub是否启用滚动时的平滑动画效果。\nmarkers是否在页面上显示触发器和动画的标记。true&#x2F;false&#x2F;object;\n markers: &#123;     endColor:&#x27;blue&#x27;,     startColor:&#x27;yellow&#x27;,     fontSize:&#x27;20px&#x27;&#125;,\n\npin是否固定元素，使其在滚动时保持可见。\nmarkers提示线 提示起始&#x2F;结束位置的线\ntoggleActions在使用 GSAP 的 ScrollTrigger 插件时，toggleActions 是一个可选的配置属性，它可以控制动画在滚动触发器的不同状态下的行为。toggleActions 属性是一个字符串，由四个值组成，分别对应四个状态：进入视口、离开视口、进入视口后再次进入视口和离开视口后再次离开视口。每个状态都有一个对应的值，它可以是字符串或函数。\n以下是 toggleActions 属性的详细解释：\n\nplay: 当元素进入视口时，动画将从头开始播放。当元素离开视口时，动画将回退到初始状。\npause: 当元素进入视口时，动画将暂停在当前位置。当元素离开视口时，动画将暂停在当前位置。\nresume: 当元素进入视口时，动画将从上次停止的位置继续播放。当元素离开视口时，动画将回退到初始状态。\nreset: 当元素进入视口时，动画将从头开始播放。当元素离开视口时，动画将回退到初始状态，并清除动画的所有状态。\nrestart: 当元素进入视口时，动画将从头开始播放。当元素离开视口时，动画将从头开始播放。\ntogglePlay: 当元素进入视口时，动画将从头开始播放或暂停。当元素离开视口时，动画将回退到初始状态或暂停。\ntoggleClass: 当元素进入视口时，将在指定的元素上添加或删除指定的类名。当元素离开视口时，将从指定的元素上添加或删除指定的类名。\n函数: 可以使用函数来自定义动画在每个状态下的行为。这个函数将接收一个布尔值参数，表示元素是否在视口中。函数应该返回一个对象，其中包含 play、pause、resume、reset、restart、togglePlay 或 toggleClass 属性，这些属性对应着每个状态的行为。\n例如，如果你想在元素进入视口后暂停动画，离开视口后回退到初始状态，再次进入视口后从上次停止的位置继续播放，可以将 toggleActions 属性设置为”pause reset resume”。\n\n","categories":["前端技术"],"tags":["CSS"]},{"title":"Vue3","url":"/2022/06/12/Vue3/","content":"他日若有凌云志vue3 初见\n\nTips：斜体下划线 &#x3D;&gt; 重点\nVue3 EventBus mitt 事件总线下载npm i mitt \n导入：// EventBus.jsimport mitt from &quot;mitt&quot;// mitt Vue3 官方推荐的事件总线处理程序const emitter  = mitt()export default emitter()\n\n使用:绑定import emitter from &quot;EventBus.js&quot;emitter.emit(&quot;why&quot;,&#123;name:&quot;wusu&quot;,age:&quot;19&quot;&#125;)\n\n触发且可以正常触发methods里的方法\nimport emitter from &quot;eventBus.js&quot;export default &#123;    created() &#123;      // 监听 why       emitter.on(&quot;why&quot;,this.Dialog);      emitter.on(&quot;kobe&quot;, (info) =&gt; &#123;        console.log(&quot;kobe:&quot;, info);      &#125;);      // 监听全部 每次触发其他时都会触发      emitter.on(&quot;*&quot;, (type, info) =&gt; &#123;        console.log(&quot;* listener:&quot;, type, info + &#x27;1&#x27;);      &#125;)    &#125;,     methods:&#123;      Dialog(e)&#123;        console.log(e) // &#123;name: &#x27;why&#x27;, age: 18&#125;      &#125;    &#125;  &#125;\n\n取消监听取消全部\nemitter.all.clear()\n\n取消单个\n// 绑定emitter.on(&quot;why&quot;,this.Dialog);// 取消emitter.off(&#x27;why&#x27;,this.Dialog)\n\nSlot使用:基本使用：匿名插槽// my-slot-cpn&lt;template&gt;  &lt;div&gt;    &lt;h5&gt;Start&lt;/h5&gt;      &lt;slot&gt;        默认      &lt;/slot&gt;    &lt;h5&gt;End&lt;/h5&gt;  &lt;/div&gt;&lt;/template&gt;//引用 //传什么都可行 甚至组件&lt;my-slot-cpn&gt;      &lt;button&gt;我是按钮&lt;/button&gt;&lt;/my-slot-cpn&gt;\n\n具名插槽&lt;template&gt;  &lt;div&gt;    &lt;h5&gt;Start&lt;/h5&gt;      &lt;slot name=&quot;come&quot;&gt;        默认      &lt;/slot&gt;    &lt;h5&gt;End&lt;/h5&gt;  &lt;/div&gt;&lt;/template&gt;//------------------------&lt;my-slot-cpn &gt;     &lt;template #come&gt; // #come 为 v-slot:come的简写      \t&lt;button&gt;我是按钮&lt;/button&gt;     &lt;template&gt;&lt;/my-slot-cpn&gt;//--------------------------&lt;my-slot-cpn :name=&quot;name&quot;&gt;    &lt;template #[name]&gt;        &lt;i&gt;why内容&lt;/i&gt;     &lt;/template&gt;&lt;/my-slot-cpn&gt;&lt;template&gt;  &lt;div&gt;      &lt;slot :name=&quot;name&quot;&gt;        默认      &lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;\n\n作用域插槽可以在绑定插槽的时候使用template 并且绑定属性（v-slot）&#x3D;”slotProps” \nslotProps的数据为 子组件slot上所绑定的属性值\n&#x2F;&#x2F; App.vue\n&lt;template&gt;  &lt;div&gt;  \t// v-solt = #default    &lt;show-names :names=&quot;names&quot;&gt;      &lt;template #default=&quot;slotProps&quot;&gt;      \t// slotProps =&gt; &#123; &quot;item&quot;: &quot;why&quot;, &quot;index&quot;: 0 &#125;        &lt;button&gt;&#123;&#123;slotProps.item&#125;&#125; + &#123;&#123;slotProps.index&#125;&#125;&lt;/button&gt;      &lt;/template&gt;    &lt;/show-names&gt;    &lt;!-- 若插槽有名字  v-slot:left =&gt; #left --&gt;     &lt;show-names :names=&quot;names&quot;&gt;      &lt;template #left=&quot;slotProps&quot;&gt;        &lt;button&gt;&#123;&#123;slotProps.item&#125;&#125; + &#123;&#123;slotProps.index + 1&#125;&#125;&lt;/button&gt;      &lt;/template&gt;    &lt;/show-names&gt;\t    &lt;!-- 如果插槽为默认 则可以下方这种写法 ==&gt; 独占默认插槽 --&gt;    &lt;show-names :names=&quot;names&quot; v-slot=&quot;slotProps&quot;&gt;         &lt;button&gt;&#123;&#123;slotProps.item&#125;&#125; + &#123;&#123;slotProps.index&#125;&#125;&lt;/button&gt;    &lt;/show-names&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import ShowNames from &#x27;./ShowNames.vue&#x27;;  export default &#123;    components: &#123;      ShowNames    &#125;,    data() &#123;      return &#123;        names: [&quot;why&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;curry&quot;]      &#125;    &#125;  &#125;&lt;/script&gt;\n\n&#x2F;&#x2F;ShowNames.vue\n&lt;template&gt;  &lt;div&gt;    &lt;template v-for=&quot;(item,index) in names&quot; :key=&quot;item&quot;&gt;      &lt;!-- 可以取不同的名字访问 但是不可以访问同样的值两次 --&gt;\t      &lt;!-- name=&quot;default&quot; 等同于不写 --&gt;      &lt;slot :item=&quot;item&quot; :index=&quot;index&quot;&gt;&lt;/slot&gt;      &lt;slot name=&quot;left&quot; :item=&quot;item&quot; :index=&quot;index&quot;&gt;&lt;/slot&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    props: &#123;      names:&#123;        type:Array,        default:()=&gt;[]      &#125;    &#125;  &#125;&lt;/script&gt;\n\n组件动态组件keep-alive&#x2F;component&#x2F;生命周期&lt;!-- include/exclude 包括=&gt; string | array | RegExp --&gt;&lt;!-- 匹配时 是根据子组件的 name属性确定的 --&gt;&lt;keep-alive  exclude=&quot;about&quot; include=&quot;home,about&quot;&gt;    &lt;component :is=&quot;currentTab&quot;                name=&quot;coderwhy&quot;                :age=&quot;18&quot;                @pageClick=&quot;pageClick&quot;&gt;    &lt;/component&gt;&lt;/keep-alive&gt;currentTab //  tabs: [&quot;home&quot;, &quot;about&quot;, &quot;category&quot;]中其一keep-alive // 缓存组件 会保留状态 并且加入两个新的生命周期函数activated 组件进入时触发deactivated 组件离开时触发若组件被缓存了离开时不会触发unmouted函数只有首次进入才会触发 created属性created() &#123;\tconsole.log(&quot;about created&quot;);&#125;,unmounted() &#123;  console.log(&quot;about unmounted&quot;);&#125;,activated() &#123;   console.log(&quot;about activated&quot;);&#125;,deactivated() &#123;   console.log(&quot;about deactivated&quot;);&#125;\n\n异步组件 默认的打包过程：\n默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组 \n件模块打包到一起（比如一个app.js文件中）；\n这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢；\n打包时，代码的分包：\n 所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js； \n 这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容；\n个人（Wusu）理解 ：可以理解为常用的路由懒记载类比的东西 分包之后使用时进行请求 ;\n() =&gt; import(&quot;组件.vue&quot;)或者(resolve) =&gt; require([&#x27;zujian.vue&#x27;],resolve)\n\nVue的异步组件\n异步组件的目的是可以对其进行分包 上线后可单独加载 速度加快\n// Vue3异步组件import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;;const AsyncCategory = defineAsyncComponent(() =&gt; import(&quot;./AsyncCategory.vue&quot;))\n\nvue Suspense （实验性属性）\nhttps://cn.vuejs.org/guide/built-ins/suspense.html#async-dependencies\n&lt;suspense&gt;      &lt;template #default&gt;        &lt;async-category&gt;&lt;/async-category&gt;      &lt;/template&gt;      &lt;template #fallback&gt;        &lt;loading&gt;&lt;/loading&gt;      &lt;/template&gt;&lt;/suspense&gt;\n\n&#x2F;&#x2F; 效果不知道 目前来看 首先显示fallback里的东西 然后显示 default的东西 速度很快会闪屏  算是个加载效果（？\nRefs(vue3)&lt;nav-bar ref=&quot;navBar&quot;&gt;&lt;/nav-bar&gt;console.log(this.$refs.navBar) // proxy拿组件属性方法之类与从前一致 拿到DOM节点要$el\n\nvue3 移除了 $children (根本没用过)\n$parent 拿到父组件 $root 拿到根元素  （&#x3D;&gt; 不推荐使用 一般还是props emits 传值 ）\n组件的v-modelVue2的写法两种写法只是绑定值的时候有所不同\n&lt;all :filetype.sync=&quot;filetype&quot;&gt;&lt;/all&gt;\n\n以下为Vue3的写法组件上使用 v-model Vue做了什么事情\n绑定一个值并且改变\n&#x2F;&#x2F; 父组件\n&lt;!-- 组件上使用v-model --&gt;&lt;hy-input v-model=&quot;message&quot;&gt;&lt;/hy-input&gt; \t\t\t||&lt;hy-input :modelValue=&quot;message&quot; @update:model-value=&quot;message = $event&quot;&gt;&lt;/hy-input&gt; \n\n&#x2F;&#x2F; 子组件\n&lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;changeValue&quot;&gt; props: &#123;    modelValue: &#123;    \ttype: [String, Array, Number],    &#125;,&#125;,//methodschangeValue(e)&#123;    this.$emit(&quot;update:model-value&quot;,e.target.value)&#125;或者 计算属性来改变外部的值 （=&gt; 目前能想到的 ele组件的 输入框）&lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt;computed:&#123;    value:&#123;        set(val)&#123;            this.$emit(&quot;update:model-value&quot;,val)        &#125;,        get()&#123;            return this.modelValue;       \t&#125;    &#125;&#125;,\n\nv-model 和 :value 绑定在组件上的区别\n&lt;!-- v-model 双向数据绑定  : 单向数据绑定 ==&gt; 简单来说 v-model的东西变了 :value 跟着变 但是 :value的数据是独立的 与外面的无瓜 --&gt;&lt;input type=&quot;text&quot; v-model:value=&quot;message&quot;&gt;&lt;input type=&quot;text&quot; :value=&quot;message&quot;&gt;\n\n&#x2F;&#x2F;改变多个值\np:两个输入框 上下分别可以对应改变message 和 title的值\n父组件\n&lt;hy-inputa v-model=&quot;message&quot; v-model:title=&quot;title&quot;&gt;&lt;/hy-inputa&gt;&#123;&#123;message&#125;&#125;&#123;&#123;title&#125;&#125;\n\nhy-inputa\n&lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt;&lt;input type=&quot;text&quot; v-model=&quot;titleTit&quot;&gt;  props: &#123;    modelValue: &#123;      type: [String, Array, Number],    &#125;,    title:String,  &#125;,      emits:[&quot;update:model-value&quot;,&quot;update:title&quot;],  computed:&#123;    value:&#123;      set(val)&#123;        this.$emit(&quot;update:model-value&quot;,val)      &#125;,      get()&#123;        return this.modelValue;      &#125;    &#125;,    titleTit:&#123;      set(val)&#123;        this.$emit(&quot;update:title&quot;,val)      &#125;,      get()&#123;        return this.title;      &#125;    &#125;  &#125;,\n\n动画基本使用注意事项\n&lt;!-- type=&quot;transition&quot; // transition 或者 animation ==&gt; 一般没啥用，过渡和动画同时存在时根据某一个来结束过渡 不然会抽搐闪烁 --&gt;mode&lt;!-- in-out ==&gt; 当前元素后离开 要加入的元素先加载 --&gt;&lt;!-- out-in ==&gt; 当前元素先离开 然后之后的在进入 --&gt;&lt;!-- appear 进入界面时 直接有动画效果 --&gt;&lt;transition name=&quot;why&quot; mode=&quot;out-in&quot;  type=&quot;animation&quot; appear&gt;\t&lt;component :is=&quot;isShow ? &#x27;home&#x27;: &#x27;about&#x27;&quot;&gt;&lt;/component&gt;&lt;/transition&gt;\n\nTransition 各阶段\nxxx-enter-from =&gt; xxx-enter-active =&gt; xxx-enter-toleave 同理\n\n直接拿animation的动画会很＜（＾－＾）＞\n添加的类名同 直接设置css动画名同理\n&lt;transition    enter-active-class=&quot;animate__animated animate__fadeInDown&quot;    leave-active-class=&quot;animate__animated animate__fadeOut&quot;    &gt;\t&lt;h2&gt;我是BBB&lt;/h2&gt;&lt;/transition&gt;\n\ngsap动画库效果为列表动画 非常丝滑\n&lt;template&gt;  &lt;div&gt;    &lt;input v-model=&quot;keyword&quot; /&gt;    &lt;transition-group tag=&quot;ul&quot; name=&quot;susu&quot; :css=&quot;false&quot;  @before-enter=&quot;beforeEnter&quot;        @enter=&quot;enter&quot;        @leave=&quot;leave&quot;&gt;      &lt;li        v-for=&quot;(item,index) in showNames&quot;        :key=&quot;item&quot;        :data-index=&quot;index&quot;      &gt;        &#123;&#123; item &#125;&#125;      &lt;/li&gt;    &lt;/transition-group&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import gsap from &quot;gsap&quot;;export default &#123;  data() &#123;    return &#123;      names: [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;, &quot;why&quot;, &quot;lilei&quot;, &quot;hmm&quot;, &quot;kobe&quot;, &quot;james&quot;],      keyword: &quot;&quot;,    &#125;;  &#125;,  computed: &#123;    showNames() &#123;      return this.names.filter((item) =&gt; item.indexOf(this.keyword) !== -1);    &#125;,  &#125;,  methods: &#123;    beforeEnter(el) &#123;      el.style.opacity = 0;      el.style.height = 0;    &#125;,    enter(el, done) &#123;      gsap.to(el, &#123;        opacity: 1,        height:&quot;1.5em&quot;,        delay:el.dataset.index * 0.1,        onComplete: done,      &#125;);    &#125;,    leave(el, done) &#123;      gsap.to(el, &#123;        opacity: 0,        height:0,        delay:el.dataset.index * 0.1,        onComplete: done,      &#125;);    &#125;,   &#125;,  mounted() &#123;  &#125;,&#125;;&lt;/script&gt;\n\nMixins 代码复用 （共享）// demoMixinexport const demoMixin = &#123;  data() &#123;    return &#123;      message: &quot;Hello DemoMixin&quot;    &#125;  &#125;,  methods: &#123;    foo() &#123;      console.log(this)      console.log(this.title);    &#125;  &#125;,  created() &#123;    console.log(&quot;执行了demo mixin created&quot;);  &#125;&#125; \n\nApp.vue 可以直接掉 等于是写在了外面的方法之类\n&lt;button @click=&quot;foo&quot;&gt;按钮&lt;/button&gt;import &#123; demoMixin &#125; from &#x27;./mixins/demoMixin&#x27;;\n\n有冲突 生命周期都执行 其他的 本体大 引入的小 \n全局混入\napp.mixin(&#123;    created() &#123;        console.log(&quot;@222&quot;)    &#125;,&#125;)\n\nextend(了解)&lt;template&gt;  &lt;div&gt;    Home Page    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;bar&quot;&gt;按钮&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  // 引入其他组件 可以使用其他的方法/数据  import BasePage from &#x27;./BasePage.vue&#x27;;  export default &#123;    extends: [BasePage],    data() &#123;      return &#123;        content: &quot;Hello Home&quot;      &#125;    &#125;  &#125;&lt;/script&gt;\n\ncomposition APIsetup (不是响应式)\n&lt;template&gt;  &lt;div&gt;    Home Page    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    props: &#123;      message: &#123;        type: String,        required: true      &#125;    &#125;,    data() &#123;      return &#123;        counter: 100      &#125;    &#125;,    /**     * 参数一: props, 父组件传递过来属性     */    // setup函数有哪些参数?    // setup函数有什么样的返回值    // setup(props, context) &#123;    setup(props, &#123;attrs, slots, emit&#125;) &#123;        // console.log(props) // props里的东西        // console.log(attrs) // 绑定的值 除去props里的东西        // console.log(slots)        // console.log(emit)      return &#123;        title: &quot;Hello Home&quot;,        counter: 100      &#125;    &#125;,    methods: &#123;      btnClick() &#123;        this.$emit(&quot;&quot;)      &#125;    &#125;  &#125;&lt;/script&gt;\n\n响应式APIsetup函数没有this:\n表达的含义是this并没有指向当前组件实例； 并且在setup被调用之前，data、computed、methods等都没有被解析； 所以无法在setup中获取this； \n\nreactiveAPIreactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型\nlet state = reactive(&#123;       counter:100, &#125;)return&#123;    state.counter&#125;\n\nref  API灵活\ntoRefs  toRef\nlet counter = ref(100)script操作 counter.value++ template模板里则直接可以 counterreturn &#123;    counter,&#125;const info = reactive(&#123;name: &quot;why&quot;, age: 18&#125;);//1.toRefs: 将reactive对象中的所有属性都转成ref, 建立链接let &#123; name, age &#125; = toRefs(info); // 可修改// 2.toRef: 对其中一个属性进行转换ref, 建立链接let &#123; name &#125; = info; // 只读let age = toRef(info, &quot;age&quot;); //可修改\n\nreadonly API只读api\nlet su = readonly(counter)传入后 su 为只读不可修改 但是可以通过改变原对象的值进行改变 一般用来 传给子组件 让子组件只读不能修改 ==&gt; 修改直接报错\n\nAPI补充isProxy检查对象是否是由 reactive 或 readonly创建的 proxy。isReactive检查对象是否是由 reactive创建的响应式代理：如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true； isReadonly检查对象是否是由 readonly 创建的只读代理。 toRaw返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。shallowReactive创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。shallowReadonly创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）。\n\nComputedimport &#123; ref, computed &#125; from &#x27;vue&#x27;;  export default &#123;    setup() &#123;      const firstName = ref(&quot;Kobe&quot;);      const lastName = ref(&quot;Bryant&quot;);      // 1.用法一: 传入一个getter函数       // computed的返回值是一个ref对象 不可变      let fullName = computed(() =&gt; firstName.value + &quot; &quot; + lastName.value);      // 2.用法二: 传入一个对象, 对象包含getter/setter 可以通过设置来改变      // const fullName = computed(&#123;      //   get: () =&gt; firstName.value + &quot; &quot; + lastName.value,      //   set(newValue) &#123;      //     const names = newValue.split(&quot; &quot;);      //     firstName.value = names[0];      //     lastName.value = names[1];      //   &#125;      // &#125;);      const changeName = () =&gt; &#123;        // firstName.value = &quot;James&quot;        // fullName.value = &quot;coder why&quot;; // 计算值为只读 ==&gt; 方法一定义        // firstName.value = &quot;Code&quot;;        // lastName.value = &quot;Why&quot;;      &#125;      return &#123;        fullName,        changeName      &#125;    &#125;  &#125;\n\nwatchEffect// watchEffect: 自动收集响应式的依赖const name = ref(&quot;why&quot;);const age = ref(18);const changeName = () =&gt; name.value = &quot;kobe&quot;const changeAge = () =&gt; age.value++const stop =  watchEffect(() =&gt; &#123;    console.log(&quot;name:&quot;, name.value, &quot;age:&quot;, age.value);    // name or age 改变值触发 会立即触发一次&#125;);return &#123;    name,    age,    changeName,    changeAge&#125;\n\n停止监听// watchEffect() 函数返回一个stop函数 调用会停止监听 比如在 age.value 大于某个值的时候 去除监听const stop = watchEffect(() =&gt; &#123;    console.log(&quot;name:&quot;, name.value, &quot;age:&quot;, age.value);&#125;);const changeName = () =&gt; name.value = &quot;kobe&quot;const changeAge = () =&gt; &#123;    age.value++;    if (age.value &gt; 25) &#123;        stop();    &#125;&#125;\n\n清楚副作用setup() &#123;      // watchEffect: 自动收集响应式的依赖      const name = ref(&quot;why&quot;);      const age = ref(18);      const stop = watchEffect((onInvalidate) =&gt; &#123;        const timer = setTimeout(() =&gt; &#123;          console.log(&quot;网络请求成功~&quot;);        &#125;, 2000)        // 根据name和age两个变量发送网络请求        onInvalidate(() =&gt; &#123;          // 在这个函数中清除额外的副作用          // request.cancel()          clearTimeout(timer);          console.log(&quot;onInvalidate&quot;);        &#125;)        // &quot;name:&quot;, name.value,         console.log(&quot;age:&quot;, age.value);      &#125;);      const changeName = () =&gt; name.value = &quot;kobe&quot;      const changeAge = () =&gt; &#123;        age.value++;        if (age.value &gt; 25) &#123;          stop();        &#125;      &#125;      return &#123;        name,        age,        changeName,        changeAge      &#125;&#125;\n\nref执行时机&lt;template&gt;  &lt;div&gt;    &lt;h2 ref=&quot;title&quot;&gt;哈哈哈&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;;  export default &#123;    setup() &#123;      const title = ref(null); // 拿到原生ref节点       console.log(title)      watchEffect(() =&gt; &#123;        console.log(title.value);      &#125;,&#123;        flush:&quot;post&quot; // 若是pre watchEffect会立即执行 打印null         //  默认值是pre 即在挂载或者更新前就执行        //  post将监听移动到组件挂载完毕后执行      &#125;)      return &#123;        title      &#125;    &#125;  &#125;&lt;/script&gt;\n\nwatch监听单个\nconst info = reactive(&#123;name: &quot;why&quot;, age: 18&#125;);// 1.侦听watch时,传入一个getter函数watch(() =&gt; info.name, (newValue, oldValue) =&gt; &#123;    console.log(&quot;newValue:&quot;, newValue, &quot;oldValue:&quot;, oldValue);&#125;)    // 2.传入一个可响应式对象: reactive对象/ref对象    // 情况一: reactive对象获取到的newValue和oldValue本身都是reactive对象    // watch(info, (newValue, oldValue) =&gt; &#123;    //   console.log(&quot;newValue:&quot;, newValue, &quot;oldValue:&quot;, oldValue);    // &#125;)    // 如果希望newValue和oldValue是一个普通的对象 &#123;...info&#125; 解构    watch(() =&gt; &#123;        return &#123;...info&#125;    &#125;, (newValue, oldValue) =&gt; &#123;        console.log(&quot;newValue:&quot;, newValue, &quot;oldValue:&quot;, oldValue);    &#125;)    // 情况二: ref对象获取newValue和oldValue是value值的本身    // const time = ref(&quot;why&quot;);    // watch(time, (newValue, oldValue) =&gt; &#123;    //   console.log(&quot;newValue:&quot;, newValue, &quot;oldValue:&quot;, oldValue);    // &#125;)    const changeData = () =&gt; &#123;    info.name = &quot;kobe&quot;;    info.age++        // time.value = &quot;Wusu&quot;&#125;return &#123;    changeData,    info,    // time&#125;\n\n监听多个\n// 1.定义可响应式的对象const info = reactive(&#123;name: &quot;why&quot;, age: 18&#125;);const name = ref(&quot;why&quot;);const title = ref(null)// 2.侦听器watch// watch([() =&gt; (&#123;...info&#125;), name,title], ([newInfo, newName,newTit],[oldInfo, oldName,oldTit]) =&gt; &#123;//   // console.log(a,b) a =&gt; newV ; b =&gt; oldV//   console.log(newInfo, newName, oldInfo, oldName);//   console.log(newTit,oldTit)// &#125;,&#123;//   // deep:true,//   // immediate:true,//   flush:&quot;post&quot;// &#125;)watch([() =&gt; (&#123;...info&#125;), name,title], (a,b) =&gt; &#123;    // console.log(a,b) a =&gt; newV ; b =&gt; oldV    console.log(a,b)&#125;,&#123;    // deep:true,    // immediate:true,    flush:&quot;post&quot;&#125;)const changeData = () =&gt; &#123;    info.name = &quot;kobe&quot;;&#125;return &#123;    changeData,    info,    title&#125;\n\n生命周期&#x2F;&#x2F; 在选项式api里卸载时与vue2有所改变 \n&#x2F;&#x2F; compositionApi 里 均有所不同 \n\n\n\n选项式Api\ncompositionApi\n\n\n\nbeforeCreate\nsetup()\n\n\ncreated\nsetup()\n\n\nbeforeMount\nonBeforeMount\n\n\nmounted\nonMounted\n\n\nbeforeUpdate\nonBeforeUpdated\n\n\nupdated\nonUpdated\n\n\nbeforeUnmount\nonBeforeUnmount\n\n\nunmounted\nonUnmounted\n\n\nactivated\nonActivated\n\n\ndeactivated\nonDeactivated\n\n\nsetup() &#123;   const counter = ref(0);   const increment = () =&gt; counter.value++;    // 都会触发   onMounted(() =&gt; &#123;     console.log(&quot;App Mounted1&quot;);   &#125;);   onMounted(() =&gt; &#123;     console.log(&quot;App Mounted2&quot;);   &#125;);   // ---------   onUpdated(() =&gt; &#123;     console.log(&quot;App onUpdated&quot;);   &#125;);   onUnmounted(() =&gt; &#123;     console.log(&quot;App onUnmounted&quot;);   &#125;);   return &#123;     counter,     increment,   &#125;; &#125;, mounted()&#123;     // 也会触发     console.log(&quot;@2333&quot;) // @2333 &#125;\n\n\n\nprovide&#x2F;inject都可以改变provide的数据 但是不建议这样子更改 一般会传递 readonly()的数据 保证单向数据流\n通过共享provide方法来改变数据\n&lt;template&gt;  &lt;div&gt;      子组件      &lt;home/&gt;    --&gt; 父组件    &lt;h2&gt;App Counter: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;increment&quot;&gt;App中的+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#123; provide, ref, readonly &#125; from &#x27;vue&#x27;;  import Home from &#x27;./Home.vue&#x27;;  export default &#123;    components: &#123;      Home    &#125;,    setup() &#123;      const name = ref(&quot;coderwhy&quot;);      let counter = ref(100);\t      // 共享属性        provide(&quot;name&quot;, readonly(name));      provide(&quot;counter&quot;, readonly(counter));      // 共享方法      provide(&quot;changeName&quot;,(val)=&gt;&#123;        name.value = val;      &#125;)      const increment = () =&gt; counter.value++;      return &#123;        increment,        counter      &#125;    &#125;  &#125;&lt;/script&gt;\n\nHooks代码逻辑拆分\nApp.vue\nimport &#123; ref, computed &#125; from &quot;vue&quot;;import &#123;  useCounter,  useLocalStorage,  useMousePosition,  useScrollPosition,  useTitle,&#125; from &quot;./hooks&quot;;export default &#123;  setup() &#123;    const &#123; num, doubbleNum, obj, addNum, delNum &#125; = useCounter();    const titleCon = useTitle(&quot;变身tit&quot;);    setTimeout(() =&gt; &#123;      titleCon.value = &quot;WuSu&quot;;    &#125;, 2000);    const &#123; scrollX, scrollY &#125; = useScrollPosition();    const &#123; mouseX, mouseY &#125; = useMousePosition();    const &#123; data &#125; = useLocalStorage(&quot;name&quot;, &#123; name: &quot;abd&quot;, age: &quot;19&quot; &#125;);    const changeData = () =&gt; (data.value = &quot;csssss&quot;);    return &#123;      num, doubbleNum,obj,addNum,delNum,      titleCon,      scrollX,scrollY,      mouseX, mouseY,      data,changeData,    &#125;;  &#125;,&#125;;\n\nhooks.js\nimport useCounter from &#x27;./useCounter&#x27;;import useTitle from &#x27;./useTitle&#x27;;import useScrollPosition from &#x27;./useScrollPosition&#x27;;import useMousePosition from &#x27;./useMousePosition&#x27;;import useLocalStorage from &#x27;./useLocalStorage&#x27;;export &#123;  useCounter,  useTitle,  useScrollPosition,  useMousePosition,  useLocalStorage&#125;\n\nuseCounter.js\nimport &#123; ref, computed &#125; from &quot;vue&quot;export default function () &#123;  const num = ref(12);  const doubbleNum = computed(() =&gt; num.value * 2)  const addNum = () =&gt; &#123;    num.value += 1  &#125;  const delNum = () =&gt; &#123;    num.value += -1  &#125;  const obj = &#123;    a:&#x27;1&#x27;,    b:&#x27;2&#x27;,  &#125;  return &#123;    num,    doubbleNum,    obj,    addNum,    delNum  &#125;&#125;\n\nrender h函数基本使用\nimport &#123; h &#125; from &#x27;vue&#x27;; export default &#123;   render() &#123;     return h(&quot;h2&quot;,&#123;class:&quot;123321 aaa&quot;&#125;,&quot;XIXIHAHA&quot;)   &#125; &#125;\n\nJSXrender() &#123;    const increment = () =&gt; this.counter++;    const decrement = () =&gt; this.counter--;    return (        &lt;div&gt;            &lt;h2&gt;当前计数: &#123;this.counter&#125;&lt;/h2&gt;            &lt;button onClick=&#123;increment&#125;&gt;+1&lt;/button&gt;            &lt;button onClick=&#123;decrement&#125;&gt;-1&lt;/button&gt;            &lt;HelloWorld&gt;&lt;/HelloWorld&gt;    \t&lt;/div&gt;    )&#125;\n\n可以在return里的东西  比较灵活 组件库用的比较多 直接div里写js\n自定义指令（Vue3）局部注册\ndirectives:&#123;    focus:&#123;        mounted(el,binding,vnode,prenode) &#123;          el.focus()        &#125;,    &#125;,&#125;  \n\n指令的钩子会传递以下几种参数：\n\nel：指令绑定到的元素。这可以用于直接操作 DOM。\nbinding：一个对象，包含以下属性。\nvalue：传递给指令的值。例如在 v-my-directive=&quot;1 + 1&quot; 中，值是 2。\noldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。\narg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 &quot;foo&quot;。\nmodifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 &#123; foo: true, bar: true &#125;。\ninstance：使用该指令的组件实例。\ndir：指令的定义对象。\n\n\nvnode：代表绑定元素的底层 VNode。\nprevNode：之前的渲染中代表指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。\n\n生命周期\n// Data加载完成后created() &#123;    &#125;,// Dom挂载前后beforeMount() &#123;  \tconsole.log(&quot;why beforeMount&quot;);&#125;,mounted() &#123;\tconsole.log(&quot;why mounted&quot;);&#125;,// 状态更新beforeUpdate() &#123;\tconsole.log(&quot;why beforeUpdate&quot;);&#125;,updated() &#123;    console.log(&quot;why updated&quot;);&#125;,// 消失解除事件绑定beforeUnmount() &#123;\tconsole.log(&quot;why beforeUnmount&quot;);&#125;,unmounted() &#123;\tconsole.log(&quot;why unmounted&quot;);&#125;\n\n案例：\n&#x2F;&#x2F; format-time\n// 外部时间库import dayjs from &#x27;dayjs&#x27;;export default function(app) &#123;  app.directive(&quot;format-time&quot;, &#123;    created(el, bindings) &#123;      bindings.formatString = &quot;YYYY-MM-DD HH:mm:ss&quot;;      if (bindings.value) &#123;        bindings.formatString = bindings.value;      &#125;    &#125;,    mounted(el, bindings) &#123;      const textContent = el.textContent;      let timestamp = parseInt(textContent);      if (textContent.length === 10) &#123;        timestamp = timestamp * 1000      &#125;      el.textContent = dayjs(timestamp).format(bindings.formatString);    &#125;  &#125;)&#125;\n\n&#x2F;&#x2F; directives.js\nimport registerFormatTime from &#x27;./format-time&#x27;;export default function registerDirectives(app) &#123;  registerFormatTime(app);&#125;\n\n&#x2F;&#x2F; main.js\nimport registerDirectives from &#x27;./directives&#x27;registerDirectives(app);\n\nteleport&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;teleport to=&quot;#why&quot;&gt; // 将下列元素加入到 id为why的div中去 ==&gt; 必须得有id为why的Div      &lt;h2&gt;当前计数&lt;/h2&gt;      &lt;button&gt;+1&lt;/button&gt;      &lt;hello-world&gt;&lt;/hello-world&gt;    &lt;/teleport&gt;    &lt;teleport to=&quot;body&quot;&gt; // 将该元素加到body末尾      &lt;span&gt;呵呵呵呵&lt;/span&gt;    &lt;/teleport&gt;  &lt;/div&gt;&lt;/template&gt;\n\nplugins插件\n// main.jsimport pluginObject from &#x27;./plugins/plugins_object&#x27;const app = createApp(App);app.use(pluginObject);\n\nexport default &#123;  install(app) &#123;    app.config.globalProperties.$name = &quot;coderwhy&quot;  &#125;&#125;// 如何拿到config里的值import &#123; getCurrentInstance &#125; from &quot;vue&quot;;setup() &#123;    const instance = getCurrentInstance();    console.log(instance.appContext.config.globalProperties.$name)// coderwhy&#125;,\n\nmini-vuerender.js 渲染器const h = (tag, props, children) =&gt; &#123;  return &#123;    tag,    props,    children,  &#125;&#125;const mount = (vnode, container) =&gt; &#123;  // vnode -&gt; dom  const el = vnode.el = document.createElement(vnode.tag);  // 添加 属性 or 方法  if (vnode.props) &#123;    for (const key in vnode.props) &#123;      const value = vnode.props[key];            // console.log(key, value)      if (key.startsWith(&#x27;on&#x27;)) &#123;        el.addEventListener(key.slice(2).toLocaleLowerCase(), value)      &#125; else &#123;        el.setAttribute(key, value)      &#125;    &#125;  &#125;  // vnode的子节点添加  if (vnode.children) &#123;    if (typeof vnode.children === &quot;string&quot;) &#123;      el.textContent = vnode.children    &#125; else &#123;      vnode.children.forEach(item =&gt; &#123;        mount(item, el)      &#125;);    &#125;  &#125;  // 添加el到父节点  container.appendChild(el);&#125;// diff算法函数/*  n1 oldVnode  n2 newVnode*/const patch = (n1, n2) =&gt; &#123;  // 新增  if (n1.tag !== n2.tag) &#123;    const parElement = n1.el.parentElement;    parElement.removeChild(n1.el)    mount(n2, parElement)  &#125; else &#123;    const el = n2.el = n1.el;    const oldProps = n1.props || &#123;&#125;;    const newProps = n2.props || &#123;&#125;;    // 改变或者新增props    for (const key in newProps) &#123;      const newValue = newProps[key];      const oldValue = oldProps[key];      if (newValue !== oldValue) &#123;        if (key.startsWith(&#x27;on&#x27;)) &#123;          el.addEventListener(key.slice(2).toLocaleLowerCase(), newValue)        &#125; else &#123;          el.setAttribute(key, newValue)        &#125;      &#125;    &#125;    // 删除props的    for (const key in oldProps) &#123;        if (key.startsWith(&quot;on&quot;)) &#123;          const value = oldProps[key];          el.removeEventListener(key.slice(2).toLocaleLowerCase(), value)        &#125;         if (!(key in newProps)) &#123;          el.removeAttribute(key)        &#125;    &#125;    // 处理children    const oldChildren = n1.children || &#123;&#125;;    const newChildren = n2.children || &#123;&#125;;    // 新child为字符串    if (typeof newChildren === &#x27;string&#x27;) &#123;      // 旧的也是字符串      if (typeof oldChildren === &#x27;string&#x27;) &#123;        el.textContent = newChildren;      &#125; else &#123;        el.innerHTML = newChildren;      &#125;    &#125; else &#123;      if (typeof oldChildren === &#x27;string&#x27;) &#123;        el.innerHTML = &#x27;&#x27;;        newChildren.forEach(item =&gt; &#123;          mount(item, el)        &#125;)      &#125; else &#123;        // 按位对比        // 给大聪明自己以后看的：patch这步过后会直接比较完共有的的 多的或者少的走后面的判断;        // vue在没有key的情况的笨办法 硬判断 拿完一样的后新的多就加 旧的多就删掉        const minLength = Math.min(oldChildren.length, newChildren.length);        for (let i = 0; i &lt; minLength; i++) &#123;          patch(oldChildren[i], newChildren[i])        &#125;        // new节点数据多 多遍历        if (newChildren.length &gt; oldChildren.length) &#123;          newChildren.slice(oldChildren.length).forEach(item =&gt; &#123;            mount(item, el)          &#125;)        &#125;        // 循环完成后 如果是old节点数据多 则去除多出来的        if (oldChildren.length &gt; newChildren.length) &#123;          oldChildren.slice(newChildren.length).forEach(item =&gt; &#123;            el.removeChild(item.el)          &#125;)        &#125;      &#125;    &#125;  &#125;&#125;\n\nreactive.js 响应式class Dep &#123;  constructor() &#123;    this.subscribers = new Set();  &#125;  depend() &#123;    if (activeEffect) &#123;      this.subscribers.add(activeEffect);    &#125;  &#125;  notify() &#123;    this.subscribers.forEach(effect =&gt; &#123;      effect();    &#125;)  &#125;&#125;let activeEffect = null;function watchEffect(effect) &#123;  activeEffect = effect;  effect();  activeEffect = null;&#125;// Map(&#123;key: value&#125;): key是一个字符串// WeakMap(&#123;key(对象): value&#125;): key是一个对象, 弱引用const targetMap = new WeakMap();function getDep(target, key) &#123;  // 1.根据对象(target)取出对应的Map对象  let depsMap = targetMap.get(target);  if (!depsMap) &#123;    depsMap = new Map();    targetMap.set(target, depsMap);  &#125;  // 2.取出具体的dep对象  let dep = depsMap.get(key);  if (!dep) &#123;    dep = new Dep();    depsMap.set(key, dep);  &#125;  return dep;&#125;// vue3对raw进行数据劫持function reactive(raw) &#123;  return new Proxy(raw, &#123;    get(target, key) &#123;      // console.log(target,key) // &#123; counter: 0, num: 20 &#125;,&#x27;counter&#x27;       const dep = getDep(target, key);      dep.depend();      return target[key];    &#125;,    set(target, key, newValue) &#123;      // console.log(target, key, newValue) //&#123; counter: 2, num: 20 &#125; &#x27;counter&#x27; 3      const dep = getDep(target, key);      target[key] = newValue;      dep.notify();    &#125;  &#125;)&#125;// vue2对raw进行数据劫持function reactive(raw) &#123;  // 遍历传入的对象的key   Object.keys(raw).forEach(key =&gt; &#123;    // dep对象    const dep = getDep(raw, key);    // value    let value = raw[key];    Object.defineProperty(raw, key, &#123;      get() &#123;        dep.depend();        return value;      &#125;,      set(newValue) &#123;        if (value !== newValue) &#123;          value = newValue;          dep.notify();        &#125;      &#125;    &#125;)  &#125;)  return raw;&#125;\n\nindex.js 挂载器function createApp(rootComponent) &#123;  return &#123;    mount(selector) &#123;      const container = document.querySelector(selector);      let isMounted = false;      let oldVNode = null;      watchEffect(function() &#123;        if (!isMounted) &#123;          oldVNode = rootComponent.render();          mount(oldVNode, container);          isMounted = true;        &#125; else &#123;          const newVNode = rootComponent.render();          patch(oldVNode, newVNode);          oldVNode = newVNode;        &#125;      &#125;)    &#125;  &#125;&#125;\n\n","categories":["前端技术"],"tags":["vue"]},{"title":"Vue 自定义指令使用","url":"/2023/05/25/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","content":"\n\n文本溢出显示省略号app.directive(&quot;ellipsis&quot;, &#123;  mounted: function (el, binding) &#123;    // 获取期望的文本行数，默认为1    const n = binding.value || 1;    // （1）实现超出n行有省略号    el.style.display = &quot;-webkit-box&quot;;    el.style.webkitBoxOrient = &quot;vertical&quot;;    el.style.webkitLineClamp = n;    el.style.overflow = &quot;hidden&quot;;    // （2）实现鼠标移入在溢出情况下才有提示文案    if (el.clientHeight &lt; el.scrollHeight) &#123;      el.title = el.innerHTML;    &#125;  &#125;,&#125;);// 使用&lt;p v-ellipsis=&quot;3&quot;&gt;  Lorem ipsum dolor, sit amet consectetur adipisicing elit. Commodi, quos  placeat corrupti libero, sit autem sequi quisquam molestias soluta a adipisci.  Omnis ullam enim quaerat accusantium voluptas impedit dolores ab.&lt;/p&gt;;\n","categories":["Vue"],"tags":["Vue"]},{"url":"/2023/09/15/Web%20Api%E7%B3%BB%E5%88%97/","content":"Web API ~ 持续更新Web SocketWebSocket - Web API 接口参考 | MDN (mozilla.org)\nuseWebSocket | VueUse\nWeb Worker后台线程运行 例如在下方例子中 使用web worker的函数调用时不会阻塞主线程 不会使倒计时出现卡顿\nuseWebWorkerFn | VueUse — 使用WebWorkerFn | Vue使用\n&lt;script lang=&quot;ts&quot; setup&gt;import &#123; useWebWorkerFn &#125; from &#x27;@vueuse/core&#x27;;function heavyTask() &#123;  const randomNumber = () =&gt; Math.trunc(Math.random() * 5_000_00);  const numbers: number[] = Array(5_000_000).fill(undefined).map(randomNumber);  numbers.sort();  return numbers.slice(0, 5);&#125;const &#123; workerFn &#125; = useWebWorkerFn(heavyTask);async function sortFun() &#123;  let res = await workerFn();  console.log(res); // 大数排序&lt;script lang=&quot;ts&quot; setup&gt;import &#123; useTimestamp, useWebWorkerFn,useDateFormat &#125; from &#x27;@vueuse/core&#x27;;function heavyTask() &#123;  const randomNumber = () =&gt; Math.trunc(Math.random() * 5_000_00);  const numbers: number[] = Array(5_000_000).fill(undefined).map(randomNumber);  numbers.sort();  return numbers.slice(0, 5);&#125;const &#123; workerFn &#125; = useWebWorkerFn(heavyTask);const time = useTimestamp()const computedTime = useDateFormat(time, &#x27;YYYY-MM-DD HH:mm:ss SSS&#x27;)async function sortFun() &#123;  let res = await workerFn(); // 流畅运行  // let res = heavyTask(); // 倒计时略微卡顿  console.log(res);&#125;sortFun();&lt;/script&gt;&lt;template&gt;  &lt;p&gt;Current Time: &lt;b&gt;&#123;&#123; computedTime &#125;&#125;&lt;/b&gt;&lt;/p&gt;&lt;/template&gt;\n\n原生方法\nif(window.Worker)&#123;  let webWorker = new Worker(&#x27;webworker.js&#x27;)  console.log(webWorker)  // 终止webWorker  // webWorker.terminate();  webWorker.postMessage(&#x27;传递消息&#x27;)  webWorker.onmessage = function(e) &#123;    console.error(e)    console.log(&#x27;Message received from worker&#x27;);  &#125;&#125;\n\n"},{"title":"XLSX 插件使用","url":"/2023/05/25/XLSX%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/","content":"不管烟波与风雨，载将离恨过江南。\n\n\nXLSX 插件使用let newObj = &#123;&#125;;this.$refs.table.columns.map((item) =&gt; &#123;  item.property &amp;&amp; (newObj[item.property] = item.label);&#125;);console.log(newObj);const sheetData = this.dataModel.map((item) =&gt; &#123;  let result = &#123;&#125;;  for (const key in item) &#123;    if (newObj[key]) &#123;      // console.log(key);      result[newObj[key]] = item[key];    &#125;  &#125;  return result;&#125;);const worksheet = XLSX.utils.json_to_sheet(sheetData, &#123;  // skipHeader:false,  // origin:&quot;A2&quot;,&#125;);const excel = XLSX.utils.book_new();let wscols = [  // 每列不同宽度px  &#123; wch: 40 &#125;,  &#123; wch: 40 &#125;,  &#123; wch: 20 &#125;,  &#123; wch: 40 &#125;,];worksheet[&quot;!cols&quot;] = wscols;let wsrows = [&#123; hpx: 60 &#125;]; // 每行固定高度pxfor (let i = 0; i &lt;= this.total; i++) &#123;  // total  列表条数  wsrows.push(&#123; hpx: 20 &#125;);&#125;worksheet[&quot;!rows&quot;] = wsrows;let sheet = [&#123;&#125;];worksheet[&quot;!merges&quot;] = [&#123; s: &#123; c: 0, r: 0 &#125;, e: &#123; c: 0, r: 0 &#125; &#125;];console.log(worksheet);XLSX.utils.book_append_sheet(excel, worksheet, &quot;Sheet1&quot;);// excel.SheetNames[0]获取到到是文件里的到第一个表格const excelBuffer = XLSX.write(excel, &#123; bookType: &quot;xlsx&quot;, type: &quot;array&quot; &#125;);const blob = new Blob([excelBuffer], &#123; type: &quot;application/octet-stream&quot; &#125;);FileSaver.saveAs(blob, `exported_table$&#123;new Date() - 0&#125;.xlsx`);\n","categories":["前端插件"],"tags":["前端插件"]},{"title":"Canvas","url":"/2022/08/01/canvas/","content":"江南无所有，聊赠一枝春。\n\n\n开启 VSCode 代码提示js 里写\n/** @type &#123;HTMLCanvasElement&#125; */\n\n创建基本图形&lt;canvas id=&quot;c1&quot; width=&quot;600&quot; height=&quot;300&quot; style=&quot;position:relative;z-index: 1;&quot;&gt;  浏览器不支持Canvas，没有canvas的滚出克&lt;/canvas&gt;\n\nlet c1 = document.getElementById(&quot;c1&quot;);let ctx = c1.getContext(&quot;2d&quot;);\n\n矩形（rect）// 填充的矩形// 矩形 x,y 宽,高ctx.fillRect(100, 100, 300, 300);// 线组成的矩形ctx.strokeRect(100, 10, 300, 300);ctx.fillRect(100, 10, 100, 100);\n\n独立区域ctx.beginPath();ctx.rect(10, 10, 100, 100);ctx.stroke();ctx.closePath();\n\n圆（arc）// x,y,半径，起始角度，结束角，(顺逆时针 默认false顺时针 true逆时针)// moveTo 绘制不连续的路径 移动原点到某个位置ctx.beginPath();ctx.arc(100, 100, 100, 0, Math.PI * 2);ctx.moveTo(150, 100);ctx.arc(100, 100, 50, 0, Math.PI);ctx.moveTo(85, 35);ctx.arc(75, 35, 10, 0, Math.PI);ctx.moveTo(135, 35);ctx.arc(125, 35, 10, 0, Math.PI);ctx.stroke();ctx.closePath();\n\n擦除（clear）let height = 0;let timer = setInterval(() =&gt; &#123;  height++;  ctx.clearRect(0, 0, c1.clientWidth, height);  if (height &gt; c1.clientHeight) &#123;    clearInterval(timer);  &#125;&#125;, 10);\n\n圆弧（arcTo）//  arc 原点到 x1,y1 到 x2,y2ctx.beginPath();ctx.moveTo(100, 100);//x,y | x,y  半径ctx.arcTo(170, 100, 50, 3, 30);ctx.stroke();ctx.closePath();\n\nquadraticCurveTo()CanvasRenderingContext2D.quadraticCurveTo() 是 Canvas 2D API 新增二次贝塞尔曲线路径的方法。它需要 2 个点。第一个点是控制点，第二个点是终点。起始点是当前路径最新的点，当创建二次贝赛尔曲线之前，可以使用 moveTo() 方法进行改变。\n第一个为原点\nctx.quadraticCurveTo(cpx, cpy, x, y);cpx控制点的 x 轴坐标。cpy控制点的 y 轴坐标。x终点的 x 轴坐标。y终点的 y 轴坐标。\n\nbezierCurveTo()CanvasRenderingContext2D.bezierCurveTo() 是 Canvas 2D API 绘制三次贝赛尔曲线路径的方法。该方法需要三个点。第一、第二个点是控制点，第三个点是结束点。起始点是当前路径的最后一个点，绘制贝赛尔曲线前，可以通过调用 moveTo() 进行修改。\n\n路径（path）// 路径var heartPath = new Path2D();heartPath.moveTo(200, 120);heartPath.bezierCurveTo(80, 20, 50, 220, 200, 250);heartPath.bezierCurveTo(350, 220, 320, 20, 200, 120);\n\n渐变（gradient）createLinearGradientlet lineColor = ctx.createLinearGradient(0, 0, 650, 0);lineColor.addColorStop(0, &quot;#e03131&quot;);lineColor.addColorStop(index, &quot;#ff8787&quot;);lineColor.addColorStop(1, &quot;#ffc9c9&quot;);\n\ncreateConicGradientlet lineColor = ctx.createConicGradient(Math.PI / 6, 120, 10);lineColor.addColorStop(0, &quot;#e03131&quot;);lineColor.addColorStop(0.2, &quot;#22b8cf&quot;);lineColor.addColorStop(1, &quot;#ffc9c9&quot;);\n\nimagelet img = new Image();img.src = &quot;./image/柴郡.jpg&quot;;img.onload = () =&gt; &#123;  var partten = ctx.createPattern(img, &quot;repeat&quot;);  ctx.fillStyle = partten;  ctx.fillRect(0, 0, 600, 200);&#125;;\n\nlinectx.lineWidth = 1;// butt// 线段末端以方形结束。// round// 线段末端以圆形结束。// square// 线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。ctx.lineCap = &quot;round&quot;;// round// 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。圆角的半径是线段的宽度。// bevel// 在相连部分的末端填充一个额外的以三角形为底的区域，每个部分都有各自独立的矩形拐角。// miter// 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。这个设置可以通过 miterLimit 属性看到效果。ctx.lineJoin = &quot;mitter&quot;;// 虚线模式 传入间隔数组ctx.setLineDash([1, 2, 3, 4]);\n\nvideo// 图片 影音var video = document.querySelector(&quot;video&quot;);var btn = document.getElementById(&quot;btn&quot;);var img = new Image();img.src = &quot;./image/柴郡.jpg&quot;;btn.onclick = function () &#123;  video.play();  render();&#125;;function render() &#123;  ctx.drawImage(video, 0, 0, 600, 400);  ctx.drawImage(img, 500, 10, 200, 100);  requestAnimationFrame(render);&#125;\n\n案例&lt;canvas id=&quot;c1&quot; width=&quot;600&quot; height=&quot;300&quot; style=&quot;position:relative;z-index: 1;&quot;&gt;  浏览器不支持Canvas&lt;/canvas&gt;&lt;br /&gt;&lt;button class=&quot;thickline button&quot;&gt;粗线条&lt;/button&gt;&lt;button class=&quot;thinline button active&quot;&gt;细线条&lt;/button&gt;&lt;button class=&quot;saveImg&quot;&gt;保存图片&lt;/button&gt;&lt;input type=&quot;color&quot; name=&quot;&quot; id=&quot;colorIpt&quot; /&gt;&lt;button class=&quot;rubber button&quot;&gt;橡皮擦&lt;/button&gt;&lt;button class=&quot;clearImg&quot;&gt;清空画板&lt;/button&gt;\n\nscript\n/** @type &#123;HTMLCanvasElement&#125; */let c1 = document.getElementById(&quot;c1&quot;);let ctx = c1.getContext(&quot;2d&quot;);let thinkBtn = document.querySelector(&quot;.thickline&quot;);let thinBtn = document.querySelector(&quot;.thinline&quot;);let saveBtn = document.querySelector(&quot;.saveImg&quot;);let colorBtn = document.querySelector(&quot;#colorIpt&quot;);let clearBtn = document.querySelector(&quot;.clearImg&quot;);let rubberBtn = document.querySelector(&quot;.rubber&quot;);ctx.fillStyle = &quot;#fff&quot;;ctx.fillRect(0, 0, 600, 300);ctx.lineJoin = &quot;round&quot;;ctx.lineCap = &quot;round&quot;;ctx.lineWidth = 3;var isDraw = false;c1.onmousedown = (e) =&gt; &#123;  isDraw = true;  ctx.beginPath();  let x = e.pageX - c1.offsetLeft;  let y = e.pageY - c1.offsetTop;  ctx.moveTo(x, y);&#125;;c1.ontouchstart = (e) =&gt; &#123;  let ev = e.targetTouches[0];  isDraw = true;  ctx.beginPath();  let x = ev.pageX - c1.offsetLeft;  let y = ev.pageY - c1.offsetTop;  ctx.moveTo(x, y);&#125;;c1.onmouseup = (e) =&gt; &#123;  isDraw = false;  ctx.closePath();&#125;;c1.ontouchcancel = (e) =&gt; &#123;  isDraw = false;  ctx.closePath();&#125;;c1.onmouseleave = (e) =&gt; &#123;  isDraw = false;  ctx.closePath();&#125;;c1.ontouchend = (e) =&gt; &#123;  isDraw = false;  ctx.closePath();&#125;;c1.onmousemove = (e) =&gt; &#123;  if (isDraw) &#123;    let x = e.pageX - c1.offsetLeft;    let y = e.pageY - c1.offsetTop;    ctx.lineTo(x, y);    ctx.stroke();  &#125; else &#123;  &#125;&#125;;c1.ontouchmove = (e) =&gt; &#123;  let ev = e.targetTouches[0];  if (isDraw) &#123;    let x = ev.pageX - c1.offsetLeft;    let y = ev.pageY - c1.offsetTop;    ctx.lineTo(x, y);    ctx.stroke();  &#125; else &#123;  &#125;&#125;;// 清空clearBtn.onclick = () =&gt; &#123;  ctx.clearRect(0, 0, 600, 300);&#125;;// 橡皮擦rubberBtn.onclick = () =&gt; &#123;  // ctx.clearRect(0, 0, 600, 300);  ctx.globalCompositeOperation = &quot;destination-out&quot;;  ctx.lineWidth = 30;  rubberBtn.classList.add(&quot;active&quot;);  thinkBtn.classList.remove(&quot;active&quot;);  thinBtn.classList.remove(&quot;active&quot;);&#125;;// 粗线条thinkBtn.onclick = () =&gt; &#123;  ctx.globalCompositeOperation = &quot;source-over&quot;;  ctx.lineWidth = 16;  thinkBtn.classList.add(&quot;active&quot;);  thinBtn.classList.remove(&quot;active&quot;);  rubberBtn.classList.remove(&quot;active&quot;);&#125;;// 细线条thinBtn.onclick = () =&gt; &#123;  ctx.globalCompositeOperation = &quot;source-over&quot;;  ctx.lineWidth = 3;  thinBtn.classList.add(&quot;active&quot;);  thinkBtn.classList.remove(&quot;active&quot;);  rubberBtn.classList.remove(&quot;active&quot;);&#125;;// 换颜色colorBtn.onchange = (e) =&gt; &#123;  ctx.strokeStyle = e.target.value;&#125;;saveBtn.onclick = (e) =&gt; &#123;  // 把img添加到界面  let urlData = c1.toDataURL();  // let img = new Image()  // img.src = urlData;  // document.body.appendChild(img)  // 下载img  var downLoada = document.createElement(&quot;a&quot;);  downLoada.setAttribute(&quot;download&quot;, &quot;酷炫签名&quot;);  downLoada.href = urlData;  downLoada.click();&#125;;\n\ntoDataURL\ntoDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为 96dpi。\n","categories":["前端技术"],"tags":["canvas"]},{"title":"css_doodle","url":"/2022/08/01/css_doodle/","content":"去岁江南见雪时，月底梅花发。\n\n\ncss_doodle&lt;css-doodle grid=&quot;2x35&quot;&gt;  :doodle &#123; grid-gap: 10px; @size:80%; &#125; background: #60569e;  width:@rand(5%,100%)&lt;/css-doodle&gt;&lt;script src=&quot;https://unpkg.com/css-doodle@0.14.2/css-doodle.min.js&quot;&gt;&lt;/script&gt;\n\nAttributes - 属性gridThe n x m follows the order of (col, row) or (x, y). The following formats of grid value are all recognizable:\n\ngrid = &quot;0&quot;\ngrid = &quot;5&quot;\ngrid = &quot;20&quot;\ngrid = &quot;5x7&quot;\ngrid = &quot;5 x 7&quot;\ngrid = &quot;5,7&quot;\n\nThere’s an alternative way to set up the grid by using the @grid property.\n:doodle &#123; @grid:4x5; &#125;\n\nuse从 css 变量导入规则\n&lt;css-doodle use=&quot;var(--rule)&quot;&gt;&lt;/css-doodle&gt;\n\ncss-doodle &#123;  --rule: (    @size: 90%; @grid: 5 / 8em; --d: @p (45deg, -45deg, 135deg, -135deg) ; --lg:      linear-gradient(@var (--d), #60569e 50%, #0000 0) ; background: @var (        --lg      ) 0 0 / 100% 100%,    @var (--lg) 0 0 / 50% 50%;  );&#125;\n\nseedAll random values will be regenerated to the same value as last time based on the seed value. It’s quite useful if you want to keep a snapshot.\n所有随机值将根据种子值重新生成为与上次相同的值。如果你想保留一个快照，它是非常有用的。\nSelectors - 选择器:doodle表示当前这个 css-doodle 的根元素 指向组件本身\n:containercontainer 是包含所有单元格的容器元素，它使用 Grid Layout。你可能想在里面设置网格间隙。\n会继承:doodle 的属性\n:container &#123;  grid-gap: 1px;  transform: rotate(45deg) scale(1.5);&#125;同:doodle &#123;  grid-gap: 1px;&#125;一致\n\n@nth(n, …)类似于 css 选择器的 nth-child(n)\n@nth(2n + 1)&#123;    :after&#123;        content:@index;        color:#ccc;    &#125;&#125;\n\n@even类似于 css 选择器的:nth-child(even) 选择双数\n@even &#123;  background: #60569e;&#125;\n\n@odd类似于 css 选择器的:nth-child(odd) 选择单数\n@odd &#123;  background: #60569e;&#125;\n\n@at(col, row)在特定的列和行上选择单元格。\n@at(4, 2) &#123;  background: #60569e;&#125;\n\n@random([ ratio ])随机选择单元格 radio 表示选中的概率 默认 0.5 期待值 0-1\n@random &#123;  background: #60569e;&#125;\n\n@row(n, …)选择某一行 – &gt; 支持 even 双数和 odd 单数选择行\n@row(3) &#123;  background: #60569e;&#125;\n\n@col(n, …)选择某一列 同上\n@match(expression)基于一般数学表达式定位单元格。变量 i, I, x, X, y 和 Y 可以不带前缀@符号用于计算\ni &#x3D;&gt; 格子\nI &#x3D;&gt; 总格子\nx，y x 轴 y 轴\nX，Y x 轴总长 y 轴总长\n@match(i &lt;= 8 || i &gt;= 18) &#123;  background: #60569e;&#125;@match(I / i == 2) &#123;    background: @var(--bgc);&#125;@match(x=y) &#123;    background: @var(--bgc);&#125;@match(X - x + 1 = y) &#123;    background: @var(--bgc);&#125;\n\nProperties@place等同于定位\n@nth(1)&#123;    @place:0 top;&#125;\n\n@shape各种形状\nhttps://css-doodle.com/#property-@shape\n@match (X - x + 1=y) &#123;  @shape: hypocycloid 5; // 内凹五边形  background: #60569e;&#125;\n\nFunctions如果函数没有形参，括号可以省略。\n@index 坐标 简写 @i@row 行 @y@col 列 @x@size-row 行宽 @X@size-col 列高 @Y@size 格子数量 @I@pick 随机选择 @p@pick-n(v1, v2,…) 顺序随机选择 @pn@pick-d(v1, v2,…) 随机选择 随机有规律 @pd@rand(start [,end]) 两数之间随机值 @r@repeat(times, value) 重复一个值数次 @rep","categories":["前端技术"],"tags":["CSS"]},{"title":".prettierrc.json","url":"/2023/06/12/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B8%B8%E7%94%A8/","content":"千万里，江南北，浙西东。\n\n\n\n.prettierrc.json\n\n&#123;  &quot;tabWidth&quot;: 2,  &quot;endOfLine&quot;: &quot;auto&quot;,  &quot;printWidth&quot;: 140,  &quot;proseWrap&quot;: &quot;preserve&quot;,  &quot;quoteProps&quot;: &quot;as-needed&quot;,  &quot;semi&quot;: true,  &quot;singleQuote&quot;: true,  &quot;trailingComma&quot;: &quot;none&quot;,  &quot;useTabs&quot;: false,  &quot;arrowParens&quot;: &quot;always&quot;,  &quot;bracketSpacing&quot;: true,  &quot;eslintIntegration&quot;: false,  &quot;vueIndentScriptAndStyle&quot;: true&#125;\n\n&#123;  &quot;tabWidth&quot;: 2, // 缩进字节数  &quot;endOfLine&quot;: &quot;auto&quot;, // 结尾是 \\n \\r \\n\\r auto  &quot;printWidth&quot;: 120, // 超过最大值换行  &quot;proseWrap&quot;: &quot;preserve&quot;, // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行  &quot;quoteProps&quot;: &quot;as-needed&quot;, // 对象的 key 仅在必要时用引号  &quot;semi&quot;: true, // 句尾添加分号  &quot;singleQuote&quot;: true, // 使用单引号代替双引号  &quot;trailingComma&quot;: &quot;none&quot;, // 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号）  &quot;useTabs&quot;: false, // 缩进不使用tab，使用空格  &quot;arrowParens&quot;: &quot;always&quot;, // (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号  &quot;bracketSpacing&quot;: true, // 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot;  &quot;eslintIntegration&quot;: true, // 使用eslint进行格式化校验  &quot;vueIndentScriptAndStyle&quot;: true // 是否缩进Vue文件中&lt;script&gt;和&lt;style&gt;标记内的代码。&#125;\n","categories":["代码格式化常用"],"tags":["CSS"]},{"title":"uview的组件u-table为什么不能正常渲染","url":"/2023/09/11/uview%E7%9A%84%E7%BB%84%E4%BB%B6u-table%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%B8%B2%E6%9F%93/","content":"我真是**了你个。\n问题描述如下 我在用 uview 1.0 版本的 table 时 发现不能正常显示.\n\n如图 表头和表格主体是错位的那么我就想了 我这个正儿八经抄的官网的 为什么不能显示呢我就去控制台拿我的神笔去看渲染如下\n\n组件源码如下\n\n看着看着我就发现这个组件为什么不对劲正常组件直接渲染但是小程序这块外面多包了一个组件名元素 u-td导致父元素的 flex 样式不生效 怎么会这样子！！！！！啊啊啊啊啊啊于是我就去找小程序渲染规则（或者说 uniapp 的？）发现了解决办法\n相关链接\n\n如此就解决了,解决后代码和效果如下\n\n\n","tags":["uniapp"]},{"title":"外链汇总-持续更新","url":"/2023/08/15/%E7%9B%B8%E5%85%B3%E5%A4%96%E9%93%BE%E8%AE%B0%E5%BD%95/","content":"外链汇总-持续更新\n\nJS 高级 + TS 高级 + 算法 + Dart\n\n\n阮一峰的个人网站 - Ruan YiFeng’s Personal Website\n\n\n阮一峰 TypeScript 指南\nDOMLAAM 的个人主页 - 关注的用户 - 掘金 (juejin.cn)\n","tags":["技术"]},{"title":"Node.js","url":"/2023/08/01/node/","content":"少年曾有凌云志\n\n\nnpm 命令\nnpm init：初始化一个新的 npm 项目，创建 package.json 文件。\nnpm install：安装一个包或一组包，并且会在当前目录存放一个 node_modules。\nnpm install &lt;package-name&gt;：安装指定的包。\nnpm install &lt;package-name&gt; --save：安装指定的包，并将其添加到 package.json 文件中的依赖列表中。\nnpm install &lt;package-name&gt; --save-dev：安装指定的包，并将其添加到 package.json 文件中的开发依赖列表中。\nnpm install -g &lt;package-name&gt;：全局安装指定的包。\nnpm update &lt;package-name&gt;：更新指定的包。\nnpm uninstall &lt;package-name&gt;：卸载指定的包。\nnpm run &lt;script-name&gt;：执行 package.json 文件中定义的脚本命令。\nnpm search &lt;keyword&gt;：搜索 npm 库中包含指定关键字的包。\nnpm info &lt;package-name&gt;：查看指定包的详细信息。\nnpm list：列出当前项目中安装的所有包。\nnpm outdated：列出当前项目中需要更新的包。\nnpm audit：检查当前项目中的依赖项是否存在安全漏洞。\nnpm publish：发布自己开发的包到 npm 库中。\nnpm login：登录到 npm 账户。\nnpm logout：注销当前 npm 账户。\nnpm link: 将本地模块链接到全局的 node_modules 目录下\nnpm config list 用于列出所有的 npm 配置信息。执行该命令可以查看当前系统和用户级别的所有 npm 配置信息，以及当前项目的配置信息（如果在项目目录下执行该命令）\nnpm get registry 用于获取当前 npm 配置中的 registry 配置项的值。registry 配置项用于指定 npm 包的下载地址，如果未指定，则默认使用 npm 官方的包注册表地址\nnpm set registry npm config set registry &lt;registry-url&gt; 命令，将 registry 配置项的值修改为指定的 &lt;registry-url&gt; 地址\n\nPackage json执行 npm init 便可以初始化一个 package.json\n\nname：项目名称，必须是唯一的字符串，通常采用小写字母和连字符的组合。\nversion：项目版本号，通常采用语义化版本号规范。\ndescription：项目描述。\nmain：项目的主入口文件路径，通常是一个 JavaScript 文件。\nkeywords：项目的关键字列表，方便他人搜索和发现该项目。\nauthor：项目作者的信息，包括姓名、邮箱、网址等。\nlicense：项目的许可证类型，可以是自定义的许可证类型或者常见的开源许可证（如 MIT、Apache 等）。\ndependencies：项目所依赖的包的列表，这些包会在项目运行时自动安装。\ndevDependencies：项目开发过程中所需要的包的列表，这些包不会随项目一起发布，而是只在开发时使用。\npeerDependencies：项目的同级依赖，即项目所需要的模块被其他模块所依赖。\nscripts：定义了一些脚本命令，比如启动项目、运行测试等。\nrepository：项目代码仓库的信息，包括类型、网址等。\nbugs：项目的 bug 报告地址。\nhomepage：项目的官方网站地址或者文档地址。\n\n\nversion 三段式版本号一般是 1.0.0 大版本号 次版本号 修订号， 大版本号一般是有重大变化才会升级， 次版本号一般是增加功能进行升级， 修订号一般是修改 bug 进行升级\n\n\nnpm install 安装模块的时候一般是扁平化安装的，但是有时候出现嵌套的情况是因为版本不同 A 依赖 C1.0, B 依赖 C1.0, D 依赖 C2.0, 此时 C 1.0 就会被放到 A B 的 node_moduels, C2.0 会被放入 D 模块下面的 node_moduels\n\nNodejs 第四章（Npm install 原理)Nodejs 第五章（Npm run 原理)Nodejs 第六章（npx)Nodejs 第七章（发布 npm 包)pnpm 关于 npm run 的改动&lt;u&gt;**看完npm run 生命周期了吗 没看完回去看**\n没错你没看错 npm 是有生命周期的\n&quot;scripts&quot;: &#123;    &quot;predev&quot;: &quot;node topost.js&quot;,     &quot;dev&quot;:&quot;node server.js&quot;,     &quot;postdev&quot;: &quot;node endpost.js&quot;&#125;\n\n若如此定义会再执行 npm run dev 之前执行 predev 中的代码 之后执行 postdev 的代码\n那么有好兄弟这个时候就问了 啊博主博主我的 pnpm 不行呀\n别急看个链接\n或者你不想看 ok\npnpm config set enable-pre-post-scripts true\n\n这样子设置就可以运行了\n","categories":["node"],"tags":["node"]}]